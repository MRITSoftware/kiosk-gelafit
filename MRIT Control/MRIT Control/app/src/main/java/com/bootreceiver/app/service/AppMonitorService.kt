package com.bootreceiver.app.serviceimport android.app.ActivityManagerimport android.app.Notificationimport android.app.NotificationChannelimport android.app.NotificationManagerimport android.app.PendingIntentimport android.app.Serviceimport android.content.Intentimport android.os.Buildimport android.os.IBinderimport android.util.Logimport androidx.core.app.NotificationCompatimport com.bootreceiver.app.Rimport com.bootreceiver.app.ui.AppSelectionActivityimport com.bootreceiver.app.utils.PreferenceManagerimport kotlinx.coroutines.CoroutineScopeimport kotlinx.coroutines.Dispatchersimport kotlinx.coroutines.Jobimport kotlinx.coroutines.delayimport kotlinx.coroutines.launch/** * Servi├ºo que monitora quando o app escolhido ├® aberto e garante que * o GelaFit Control esteja sempre rodando em background para receber comandos *  * Este servi├ºo: * 1. Monitora periodicamente qual app est├í em foreground * 2. Quando detecta que o app escolhido est├í aberto, garante que o GelaFit Control esteja rodando * 3. Inicia automaticamente o AppRestartMonitorService se n├úo estiver rodando * 4. Funciona em background mesmo quando o app est├í fechado */class AppMonitorService : Service() {        private val serviceScope = CoroutineScope(Dispatchers.Main + Job())    private var isRunning = false    private lateinit var preferenceManager: PreferenceManager    private var targetPackageName: String? = null    private var lastForegroundApp: String? = null        override fun onBind(intent: Intent?): IBinder? = null        override fun onCreate() {        super.onCreate()        Log.d(TAG, "AppMonitorService criado")        preferenceManager = PreferenceManager(this)        targetPackageName = preferenceManager.getTargetPackageName()        createNotificationChannel()    }        override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {        if (isRunning) {            Log.d(TAG, "Servi├ºo j├í est├í rodando")            return START_STICKY        }                try {            isRunning = true            targetPackageName = preferenceManager.getTargetPackageName()            Log.d(TAG, "AppMonitorService iniciado. Monitorando app: $targetPackageName")                        // Garante que o canal de notifica├º├úo existe            createNotificationChannel()                        // Inicia como Foreground Service            try {                val notification = createNotification()                startForeground(NOTIFICATION_ID, notification)                Log.d(TAG, "Foreground Service iniciado com sucesso")            } catch (e: Exception) {                Log.e(TAG, "Erro ao iniciar Foreground Service: ${e.message}", e)            }                        // Garante que o AppRestartMonitorService est├í rodando            ensureAppRestartMonitorServiceRunning()                        // Inicia o monitoramento em uma coroutine            serviceScope.launch {                startMonitoring()            }        } catch (e: Exception) {            Log.e(TAG, "Erro cr├¡tico ao iniciar servi├ºo: ${e.message}", e)            isRunning = false        }                return START_STICKY    }        /**     * Cria o canal de notifica├º├úo (necess├írio para Android 8.0+)     */    private fun createNotificationChannel() {        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {            val channel = NotificationChannel(                CHANNEL_ID,                "Monitoramento de App",                NotificationManager.IMPORTANCE_LOW            ).apply {                description = "Monitora quando o app escolhido ├® aberto"                setShowBadge(false)            }                        val notificationManager = getSystemService(NotificationManager::class.java)            notificationManager.createNotificationChannel(channel)        }    }        /**     * Cria a notifica├º├úo para o Foreground Service     */    private fun createNotification(): Notification {        val intent = Intent(this, AppSelectionActivity::class.java)        val pendingIntentFlags = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {            PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE        } else {            PendingIntent.FLAG_UPDATE_CURRENT        }                val pendingIntent = PendingIntent.getActivity(            this,            0,            intent,            pendingIntentFlags        )                val smallIcon = android.R.drawable.ic_dialog_info                val targetApp = targetPackageName ?: "Nenhum"        val statusText = if (targetPackageName != null) {            "Monitorando: $targetApp"        } else {            "Aguardando configura├º├úo..."        }                return NotificationCompat.Builder(this, CHANNEL_ID)            .setContentTitle("GelaFit Control - Monitorando")            .setContentText(statusText)            .setSmallIcon(smallIcon)            .setContentIntent(pendingIntent)            .setOngoing(true)            .setPriority(NotificationCompat.PRIORITY_LOW)            .setCategory(NotificationCompat.CATEGORY_SERVICE)            .setAutoCancel(false)            .build()    }        /**     * Garante que o AppRestartMonitorService est├í rodando     */    private fun ensureAppRestartMonitorServiceRunning() {        try {            if (!isServiceRunning(AppRestartMonitorService::class.java)) {                Log.d(TAG, "AppRestartMonitorService n├úo est├í rodando. Iniciando...")                val monitorIntent = Intent(this, AppRestartMonitorService::class.java)                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {                    startForegroundService(monitorIntent)                } else {                    startService(monitorIntent)                }                Log.d(TAG, "AppRestartMonitorService iniciado")            } else {                Log.d(TAG, "AppRestartMonitorService j├í est├í rodando")            }        } catch (e: Exception) {            Log.e(TAG, "Erro ao iniciar AppRestartMonitorService: ${e.message}", e)        }    }        /**     * Verifica se um servi├ºo est├í rodando     */    private fun isServiceRunning(serviceClass: Class<*>): Boolean {        try {            val activityManager = getSystemService(ActivityManager::class.java)            val runningServices = activityManager.getRunningServices(Integer.MAX_VALUE)                        for (service in runningServices) {                if (serviceClass.name == service.service.className) {                    return true                }            }            return false        } catch (e: Exception) {            Log.e(TAG, "Erro ao verificar se servi├ºo est├í rodando: ${e.message}", e)            return false        }    }        /**     * Inicia o monitoramento peri├│dico do app em foreground     */    private suspend fun startMonitoring() {        while (isRunning) {            try {                // Atualiza o targetPackageName caso tenha mudado                targetPackageName = preferenceManager.getTargetPackageName()                                if (targetPackageName.isNullOrEmpty()) {                    Log.d(TAG, "Nenhum app configurado. Aguardando...")                    delay(CHECK_INTERVAL_MS)                    continue                }                                // Verifica qual app est├í em foreground                val foregroundApp = getForegroundApp()                                if (foregroundApp != null) {                    // Se o app escolhido est├í em foreground                    if (foregroundApp == targetPackageName) {                        if (lastForegroundApp != foregroundApp) {                            Log.d(TAG, "Ô£à App escolhido detectado em foreground: $foregroundApp")                            lastForegroundApp = foregroundApp                                                        // Garante que o AppRestartMonitorService est├í rodando                            ensureAppRestartMonitorServiceRunning()                                                        // Garante que o GelaFit Control est├í rodando em background                            // (j├í est├í rodando porque este servi├ºo est├í ativo)                            Log.d(TAG, "GelaFit Control est├í conectado e monitorando comandos")                        }                    } else {                        // Outro app est├í em foreground                        if (lastForegroundApp == targetPackageName) {                            Log.d(TAG, "App escolhido saiu de foreground. App atual: $foregroundApp")                            lastForegroundApp = foregroundApp                        }                    }                }                                // Sempre garante que o AppRestartMonitorService est├í rodando                // mesmo quando o app escolhido n├úo est├í em foreground                ensureAppRestartMonitorServiceRunning()                                // Aguarda antes da pr├│xima verifica├º├úo                delay(CHECK_INTERVAL_MS)                            } catch (e: Exception) {                Log.e(TAG, "Erro no monitoramento: ${e.message}", e)                delay(ERROR_RETRY_DELAY_MS)            }        }    }        /**     * Obt├®m o package name do app que est├í em foreground     * Usa m├║ltiplos m├®todos para garantir compatibilidade     */    private fun getForegroundApp(): String? {        try {            val activityManager = getSystemService(ActivityManager::class.java)                        // M├®todo 1: Verifica processos em foreground (mais confi├ível)            val runningProcesses = activityManager.runningAppProcesses            if (runningProcesses != null) {                // Ordena por import├óncia - pega o mais importante primeiro                val foregroundProcesses = runningProcesses                    .filter {                         it.importance == ActivityManager.RunningAppProcessInfo.IMPORTANCE_FOREGROUND ||                        it.importance == ActivityManager.RunningAppProcessInfo.IMPORTANCE_FOREGROUND_SERVICE                    }                    .sortedByDescending { it.importance }                                if (foregroundProcesses.isNotEmpty()) {                    // Pega o primeiro pacote do processo mais importante                    val topProcess = foregroundProcesses[0]                    val packageName = topProcess.pkgList?.getOrNull(0)                    if (packageName != null) {                        // Evita retornar o pr├│prio pacote do GelaFit Control                        if (packageName != "com.bootreceiver.app") {                            return packageName                        }                    }                }            }                        // M├®todo 2: Android 6.0+ - usa getAppTasks            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {                val appTasks = activityManager.appTasks                if (appTasks != null && appTasks.isNotEmpty()) {                    for (task in appTasks) {                        val taskInfo = task.taskInfo                        if (taskInfo != null && taskInfo.topActivity != null) {                            val packageName = taskInfo.topActivity!!.packageName                            // Evita retornar o pr├│prio pacote                            if (packageName != "com.bootreceiver.app") {                                return packageName                            }                        }                    }                }            } else {                // M├®todo 3: Android 5.1 e abaixo - usa getRunningTasks (deprecated mas funciona)                @Suppress("DEPRECATION")                val runningTasks = activityManager.getRunningTasks(1)                if (runningTasks.isNotEmpty()) {                    val topActivity = runningTasks[0].topActivity                    if (topActivity != null) {                        val packageName = topActivity.packageName                        // Evita retornar o pr├│prio pacote                        if (packageName != "com.bootreceiver.app") {                            return packageName                        }                    }                }            }                        return null        } catch (e: Exception) {            Log.e(TAG, "Erro ao obter app em foreground: ${e.message}", e)            return null        }    }        override fun onDestroy() {        super.onDestroy()        isRunning = false        Log.d(TAG, "AppMonitorService destru├¡do - tentando reiniciar...")                // Se o servi├ºo foi destru├¡do, tenta reiniciar        // Isso garante que o servi├ºo continue funcionando mesmo se for morto pelo sistema        serviceScope.launch {            try {                delay(2000) // Aguarda 2 segundos                Log.d(TAG, "­ƒöä Reiniciando AppMonitorService em background...")                val restartIntent = Intent(this@AppMonitorService, AppMonitorService::class.java)                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {                    startForegroundService(restartIntent)                } else {                    startService(restartIntent)                }                                // Tamb├®m agenda um rein├¡cio usando AlarmManager como backup                scheduleRestart()            } catch (e: Exception) {                Log.e(TAG, "Erro ao tentar reiniciar servi├ºo: ${e.message}", e)                scheduleRestart()            }        }    }        /**     * Agenda um rein├¡cio do servi├ºo usando AlarmManager     * Isso garante que o servi├ºo seja reiniciado mesmo se o app estiver completamente fechado     */    private fun scheduleRestart() {        try {            val alarmManager = getSystemService(android.content.Context.ALARM_SERVICE) as android.app.AlarmManager            val restartIntent = Intent(this, AppMonitorService::class.java)            val pendingIntentFlags = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {                PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE            } else {                PendingIntent.FLAG_UPDATE_CURRENT            }            val pendingIntent = PendingIntent.getService(                this,                0,                restartIntent,                pendingIntentFlags            )                        // Agenda rein├¡cio em 5 segundos            val triggerTime = System.currentTimeMillis() + 5000            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {                alarmManager.setExactAndAllowWhileIdle(                    android.app.AlarmManager.RTC_WAKEUP,                    triggerTime,                    pendingIntent                )            } else {                @Suppress("DEPRECATION")                alarmManager.setExact(android.app.AlarmManager.RTC_WAKEUP, triggerTime, pendingIntent)            }                        Log.d(TAG, "ÔÅ░ Rein├¡cio do servi├ºo agendado em 5 segundos")        } catch (e: Exception) {            Log.e(TAG, "Erro ao agendar rein├¡cio: ${e.message}", e)        }    }        override fun onTaskRemoved(rootIntent: Intent?) {        super.onTaskRemoved(rootIntent)        Log.d(TAG, "ÔÜá´©Å App removido da lista de tarefas - mas servi├ºo continua rodando")        // O servi├ºo continua rodando mesmo se o app for fechado        // START_STICKY garante que ser├í reiniciado se necess├írio    }        companion object {        private const val TAG = "AppMonitorService"        private const val CHANNEL_ID = "app_monitor_channel"        private const val NOTIFICATION_ID = 2        private const val CHECK_INTERVAL_MS = 5000L // Verifica a cada 5 segundos        private const val ERROR_RETRY_DELAY_MS = 10000L // Em caso de erro, aguarda 10 segundos    }}