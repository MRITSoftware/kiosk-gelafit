package com.bootreceiver.app.serviceimport android.app.Notificationimport android.app.NotificationChannelimport android.app.NotificationManagerimport android.app.PendingIntentimport android.app.Serviceimport android.content.Intentimport android.os.Buildimport android.os.IBinderimport android.util.Logimport androidx.core.app.NotificationCompatimport com.bootreceiver.app.Rimport com.bootreceiver.app.ui.AppSelectionActivityimport com.bootreceiver.app.utils.AppLauncherimport com.bootreceiver.app.utils.DeviceIdManagerimport com.bootreceiver.app.utils.PreferenceManagerimport com.bootreceiver.app.utils.SupabaseManagerimport kotlinx.coroutines.CoroutineScopeimport kotlinx.coroutines.Dispatchersimport kotlinx.coroutines.Jobimport kotlinx.coroutines.delayimport kotlinx.coroutines.launch/** * Servi├ºo que monitora periodicamente o Supabase para verificar * se h├í comandos de reiniciar o app configurado *  * Este servi├ºo: * 1. Verifica a cada 30 segundos se h├í um comando de reiniciar app * 2. Se encontrar, fecha e reabre o app configurado * 3. Marca o comando como executado ap├│s reiniciar */class AppRestartMonitorService : Service() {        private val serviceScope = CoroutineScope(Dispatchers.Main + Job())    private var isRunning = false    private val supabaseManager = SupabaseManager()    private lateinit var unitName: String    private var isRestarting = false // Flag para evitar m├║ltiplos rein├¡cios simult├óneos    private val processedCommandIds = mutableSetOf<String>() // IDs de comandos j├í processados nesta sess├úo        override fun onBind(intent: Intent?): IBinder? = null        override fun onCreate() {        super.onCreate()        Log.d(TAG, "AppRestartMonitorService criado")        val preferenceManager = PreferenceManager(this)        unitName = preferenceManager.getUnitName() ?: ""        createNotificationChannel()    }        override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {        if (isRunning) {            Log.d(TAG, "Servi├ºo j├í est├í rodando")            return START_STICKY        }                try {            isRunning = true            val preferenceManager = PreferenceManager(this)            unitName = preferenceManager.getUnitName() ?: ""            Log.d(TAG, "AppRestartMonitorService iniciado para unidade: $unitName")                        // Garante que o canal de notifica├º├úo existe            createNotificationChannel()                        // Inicia como Foreground Service            try {                val notification = createNotification()                startForeground(NOTIFICATION_ID, notification)                Log.d(TAG, "Foreground Service iniciado com sucesso")            } catch (e: Exception) {                Log.e(TAG, "Erro ao iniciar Foreground Service: ${e.message}", e)            }                        // Inicia o monitoramento em uma coroutine            serviceScope.launch {                startMonitoring()            }        } catch (e: Exception) {            Log.e(TAG, "Erro cr├¡tico ao iniciar servi├ºo: ${e.message}", e)            isRunning = false        }                return START_STICKY    }        /**     * Cria o canal de notifica├º├úo (necess├írio para Android 8.0+)     */    private fun createNotificationChannel() {        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {            val channel = NotificationChannel(                CHANNEL_ID,                "Monitoramento de App",                NotificationManager.IMPORTANCE_LOW            ).apply {                description = "Monitora comandos de reiniciar app do Supabase"                setShowBadge(false)            }                        val notificationManager = getSystemService(NotificationManager::class.java)            notificationManager.createNotificationChannel(channel)        }    }        /**     * Cria a notifica├º├úo para o Foreground Service     */    private fun createNotification(): Notification {        val intent = Intent(this, AppSelectionActivity::class.java)        val pendingIntentFlags = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {            PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE        } else {            PendingIntent.FLAG_UPDATE_CURRENT        }                val pendingIntent = PendingIntent.getActivity(            this,            0,            intent,            pendingIntentFlags        )                val smallIcon = android.R.drawable.ic_dialog_info                return NotificationCompat.Builder(this, CHANNEL_ID)            .setContentTitle("MRIT Control GelaFit - Monitorando")            .setContentText("Monitorando comandos de reiniciar app...")            .setSmallIcon(smallIcon)            .setContentIntent(pendingIntent)            .setOngoing(true)            .setPriority(NotificationCompat.PRIORITY_LOW)            .setCategory(NotificationCompat.CATEGORY_SERVICE)            .setAutoCancel(false)            .build()    }        /**     * Inicia o monitoramento peri├│dico do banco de dados     */    private suspend fun startMonitoring() {        while (isRunning) {            try {                Log.d(TAG, "ÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöü")                Log.d(TAG, "­ƒöì Ciclo de verifica├º├úo #${System.currentTimeMillis() / CHECK_INTERVAL_MS}")                Log.d(TAG, "Unit Name: $unitName")                                if (unitName.isBlank()) {                    Log.w(TAG, "ÔÜá´©Å Unit name n├úo configurado. Aguardando...")                    delay(CHECK_INTERVAL_MS)                    continue                }                                // Verifica se j├í est├í reiniciando (evita m├║ltiplos rein├¡cios simult├óneos)                if (isRestarting) {                    Log.d(TAG, "ÔÅ│ Rein├¡cio j├í em andamento, aguardando...")                    delay(CHECK_INTERVAL_MS)                    continue                }                                // Busca comando pendente (retorna o ID do comando se houver)                val commandInfo = supabaseManager.getRestartAppCommand(unitName)                                if (commandInfo != null) {                    val commandId = commandInfo.id                                        // Verifica se este comando j├í foi processado nesta sess├úo                    if (commandId != null && processedCommandIds.contains(commandId)) {                        Log.d(TAG, "Ôä╣´©Å Comando j├í foi processado nesta sess├úo, ignorando...")                        delay(CHECK_INTERVAL_MS)                        continue                    }                                        Log.d(TAG, "ÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöü")                    Log.d(TAG, "ÔÜá´©ÅÔÜá´©ÅÔÜá´©Å COMANDO DE REINICIAR APP ENCONTRADO! ÔÜá´©ÅÔÜá´©ÅÔÜá´©Å")                    Log.d(TAG, "ÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöü")                                        // Marca que est├í reiniciando                    isRestarting = true                                        // Obt├®m o app/URL configurado                    val preferenceManager = PreferenceManager(this@AppRestartMonitorService)                    val pwaUrl = preferenceManager.getPWAUrl()                    val targetPackageName = preferenceManager.getTargetPackageName()                    val targetToRestart = pwaUrl ?: targetPackageName                                        if (targetToRestart.isNullOrEmpty()) {                        Log.w(TAG, "Nenhum app ou URL configurado. N├úo ├® poss├¡vel reiniciar.")                        // Marca como executado mesmo assim para n├úo ficar em loop                        val marked = supabaseManager.markCommandAsExecutedById(commandId)                        if (marked) {                            Log.d(TAG, "Ô£à Comando marcado como executado (sem app/URL configurado)")                            if (commandId != null) processedCommandIds.add(commandId)                        } else {                            Log.e(TAG, "ÔØî Falha ao marcar comando como executado!")                        }                        isRestarting = false                    } else {                        Log.d(TAG, "App/URL configurado: $targetToRestart")                                                // CR├ìTICO: Marca como executado ANTES de reiniciar                        // Isso garante que mesmo se o app reiniciar, o comando j├í est├í marcado                        Log.d(TAG, "­ƒôØ Marcando comando como executado no Supabase...")                        val marked = supabaseManager.markCommandAsExecutedById(commandId)                                                if (!marked) {                            Log.e(TAG, "ÔØî FALHA CR├ìTICA: N├úo foi poss├¡vel marcar comando como executado!")                            Log.e(TAG, "ÔÜá´©Å Tentando deletar comando como alternativa...")                            // Tenta deletar como alternativa                            val deleted = supabaseManager.deleteCommandById(commandId)                            if (!deleted) {                                Log.e(TAG, "ÔØî Tamb├®m falhou ao deletar comando. Abortando rein├¡cio.")                                delay(ERROR_RETRY_DELAY_MS)                                isRestarting = false                                continue                            } else {                                Log.d(TAG, "Ô£à Comando deletado como alternativa")                            }                        } else {                            Log.d(TAG, "Ô£à Comando marcado como executado com sucesso!")                        }                                                // Adiciona ├á lista de comandos processados                        if (commandId != null) {                            processedCommandIds.add(commandId)                        }                                                // Verifica novamente se o comando foi realmente processado (double-check)                        delay(2000) // Aguarda 2 segundos para garantir que foi salvo no banco                        val stillHasCommand = supabaseManager.getRestartAppCommand(unitName)                        if (stillHasCommand != null && stillHasCommand.id == commandId) {                            Log.w(TAG, "ÔÜá´©Å Comando ainda aparece como pendente ap├│s processar!")                            Log.w(TAG, "ÔÜá´©Å Tentando deletar como fallback...")                            supabaseManager.deleteCommandById(commandId)                            delay(1000)                        }                                                // Reinicia o app ou URL                        Log.d(TAG, "­ƒöä Reiniciando app/URL: $targetToRestart")                        val appLauncher = AppLauncher(this@AppRestartMonitorService)                                                // Se for URL, apenas abre novamente (navegador)                        val success = if (pwaUrl != null) {                            appLauncher.launchUrl(pwaUrl)                        } else {                            appLauncher.restartApp(targetPackageName!!)                        }                                                if (success) {                            Log.d(TAG, "ÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöü")                            Log.d(TAG, "Ô£àÔ£àÔ£à APP REINICIADO COM SUCESSO! Ô£àÔ£àÔ£à")                            Log.d(TAG, "Ô£à Comando foi executado e marcado como executado no banco")                            Log.d(TAG, "Ôä╣´©Å N├úo reiniciar├í novamente at├® que um NOVO comando seja criado")                            Log.d(TAG, "ÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöüÔöü")                        } else {                            Log.e(TAG, "ÔØî Falha ao reiniciar app: $targetPackageName")                        }                                                // Libera flag de rein├¡cio ap├│s um tempo                        delay(5000) // Aguarda 5 segundos antes de liberar                        isRestarting = false                    }                } else {                    Log.d(TAG, "Ôä╣´©Å Nenhum comando de reiniciar app pendente")                    // Se n├úo h├í comando, reseta flag de rein├¡cio (caso tenha ficado travada)                    if (isRestarting) {                        Log.w(TAG, "ÔÜá´©Å Flag de rein├¡cio estava travada, resetando...")                        isRestarting = false                    }                }                                // Aguarda antes da pr├│xima verifica├º├úo                delay(CHECK_INTERVAL_MS)                            } catch (e: Exception) {                Log.e(TAG, "Erro no monitoramento: ${e.message}", e)                // Em caso de erro, aguarda um pouco antes de tentar novamente                delay(ERROR_RETRY_DELAY_MS)            }        }    }        override fun onDestroy() {        super.onDestroy()        isRunning = false        Log.d(TAG, "AppRestartMonitorService destru├¡do - tentando reiniciar...")                // Se o servi├ºo foi destru├¡do, tenta reiniciar        // Isso garante que o servi├ºo continue funcionando mesmo se for morto pelo sistema        serviceScope.launch {            try {                delay(2000) // Aguarda 2 segundos                Log.d(TAG, "­ƒöä Reiniciando AppRestartMonitorService em background...")                val restartIntent = Intent(this@AppRestartMonitorService, AppRestartMonitorService::class.java)                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {                    startForegroundService(restartIntent)                } else {                    startService(restartIntent)                }                                // Tamb├®m agenda um rein├¡cio usando AlarmManager como backup                scheduleRestart()            } catch (e: Exception) {                Log.e(TAG, "Erro ao tentar reiniciar servi├ºo: ${e.message}", e)                scheduleRestart()            }        }    }        /**     * Agenda um rein├¡cio do servi├ºo usando AlarmManager     * Isso garante que o servi├ºo seja reiniciado mesmo se o app estiver completamente fechado     */    private fun scheduleRestart() {        try {            val alarmManager = getSystemService(android.content.Context.ALARM_SERVICE) as android.app.AlarmManager            val restartIntent = Intent(this, AppRestartMonitorService::class.java)            val pendingIntentFlags = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {                PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE            } else {                PendingIntent.FLAG_UPDATE_CURRENT            }            val pendingIntent = PendingIntent.getService(                this,                0,                restartIntent,                pendingIntentFlags            )                        // Agenda rein├¡cio em 5 segundos            val triggerTime = System.currentTimeMillis() + 5000            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {                alarmManager.setExactAndAllowWhileIdle(                    android.app.AlarmManager.RTC_WAKEUP,                    triggerTime,                    pendingIntent                )            } else {                @Suppress("DEPRECATION")                alarmManager.setExact(android.app.AlarmManager.RTC_WAKEUP, triggerTime, pendingIntent)            }                        Log.d(TAG, "ÔÅ░ Rein├¡cio do servi├ºo agendado em 5 segundos")        } catch (e: Exception) {            Log.e(TAG, "Erro ao agendar rein├¡cio: ${e.message}", e)        }    }        override fun onTaskRemoved(rootIntent: Intent?) {        super.onTaskRemoved(rootIntent)        Log.d(TAG, "ÔÜá´©Å App removido da lista de tarefas - mas servi├ºo continua rodando")        // O servi├ºo continua rodando mesmo se o app for fechado        // START_STICKY garante que ser├í reiniciado se necess├írio    }        companion object {        private const val TAG = "AppRestartMonitor"        private const val CHANNEL_ID = "app_restart_monitor_channel"        private const val NOTIFICATION_ID = 1        private const val CHECK_INTERVAL_MS = 30000L // Verifica a cada 30 segundos        private const val ERROR_RETRY_DELAY_MS = 60000L // Em caso de erro, aguarda 1 minuto    }}