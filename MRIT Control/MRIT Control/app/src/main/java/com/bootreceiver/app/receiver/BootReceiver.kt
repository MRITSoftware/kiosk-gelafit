package com.bootreceiver.app.receiverimport android.content.BroadcastReceiverimport android.content.Contextimport android.content.Intentimport android.util.Logimport com.bootreceiver.app.service.BootServiceimport com.bootreceiver.app.utils.PermissionCheckerimport com.bootreceiver.app.utils.PreferenceManager/** * BroadcastReceiver que escuta o evento de boot completo do Android *  * Quando o dispositivo ├® ligado ou reiniciado, o sistema Android envia * o broadcast BOOT_COMPLETED. Este receiver captura esse evento e inicia * o servi├ºo que verifica internet e abre o app configurado. */class BootReceiver : BroadcastReceiver() {        override fun onReceive(context: Context, intent: Intent) {        when (intent.action) {            Intent.ACTION_BOOT_COMPLETED,            "android.intent.action.QUICKBOOT_POWERON" -> {                Log.d(TAG, "Boot detectado! Iniciando processo...")                                // Verifica permiss├Áes e otimiza├º├Áes                val permissionChecker = PermissionChecker(context)                val status = permissionChecker.getFullStatus()                                if (!status.isReady) {                    Log.w(TAG, "Problemas detectados que podem impedir funcionamento:")                    status.issues.forEach { issue ->                        Log.w(TAG, "  - $issue")                    }                    // Continua mesmo assim, mas registra o problema                } else {                    Log.d(TAG, "Todas as permiss├Áes e otimiza├º├Áes est├úo corretas")                }                                // Verifica se j├í foi configurado um app para iniciar                val preferenceManager = PreferenceManager(context)                val targetPackageName = preferenceManager.getTargetPackageName()                                if (targetPackageName.isNullOrEmpty()) {                    Log.w(TAG, "Nenhum app configurado. Abrindo tela de sele├º├úo...")                    // Se n├úo houver app configurado, abre a tela de sele├º├úo                    // Usa FLAG_ACTIVITY_NEW_TASK e FLAG_ACTIVITY_CLEAR_TOP para garantir que abra mesmo com tela bloqueada                    val selectionIntent = Intent(context,                         com.bootreceiver.app.ui.AppSelectionActivity::class.java).apply {                        flags = Intent.FLAG_ACTIVITY_NEW_TASK or                                 Intent.FLAG_ACTIVITY_CLEAR_TOP or                                Intent.FLAG_ACTIVITY_SINGLE_TOP                        // Tenta abrir mesmo com tela bloqueada (requer permiss├úo em Android 10+)                        addFlags(Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS)                    }                    try {                        context.startActivity(selectionIntent)                        Log.d(TAG, "Tela de sele├º├úo iniciada")                    } catch (e: Exception) {                        Log.e(TAG, "Erro ao abrir tela de sele├º├úo: ${e.message}", e)                    }                } else {                    Log.d(TAG, "App alvo configurado: $targetPackageName")                    // Inicia o servi├ºo que verifica internet e abre o app                    val serviceIntent = Intent(context, BootService::class.java)                    try {                        context.startService(serviceIntent)                        Log.d(TAG, "BootService iniciado")                    } catch (e: Exception) {                        Log.e(TAG, "Erro ao iniciar BootService: ${e.message}", e)                    }                }                                // Sempre inicia o servi├ºo de monitoramento de app (monitora quando app escolhido ├® aberto)                val appMonitorIntent = Intent(context,                     com.bootreceiver.app.service.AppMonitorService::class.java)                try {                    if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.O) {                        context.startForegroundService(appMonitorIntent)                    } else {                        context.startService(appMonitorIntent)                    }                    Log.d(TAG, "AppMonitorService iniciado")                } catch (e: Exception) {                    Log.e(TAG, "Erro ao iniciar AppMonitorService: ${e.message}", e)                }                                // Sempre inicia o servi├ºo de monitoramento de comandos de reiniciar app                val restartMonitorIntent = Intent(context,                     com.bootreceiver.app.service.AppRestartMonitorService::class.java)                try {                    if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.O) {                        context.startForegroundService(restartMonitorIntent)                    } else {                        context.startService(restartMonitorIntent)                    }                    Log.d(TAG, "AppRestartMonitorService iniciado")                } catch (e: Exception) {                    Log.e(TAG, "Erro ao iniciar AppRestartMonitorService: ${e.message}", e)                }                                // Inicia o servi├ºo de monitoramento de modo kiosk                val kioskIntent = Intent(context,                     com.bootreceiver.app.service.KioskModeService::class.java)                try {                    if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.O) {                        context.startForegroundService(kioskIntent)                    } else {                        context.startService(kioskIntent)                    }                    Log.d(TAG, "KioskModeService iniciado")                } catch (e: Exception) {                    Log.e(TAG, "Erro ao iniciar KioskModeService: ${e.message}", e)                }                                // Inicia o WorkManager para verificar modo kiosk mesmo quando app est├í fechado                try {                    com.bootreceiver.app.worker.KioskModeWorker.start(context)                    Log.d(TAG, "KioskModeWorker iniciado")                } catch (e: Exception) {                    Log.e(TAG, "Erro ao iniciar KioskModeWorker: ${e.message}", e)                }            }            else -> {                Log.w(TAG, "A├º├úo desconhecida recebida: ${intent.action}")            }        }    }        companion object {        private const val TAG = "BootReceiver"    }}